<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RabbitMQ8]]></title>
    <url>%2F2019%2F09%2F06%2FRabbitMQ8%2F</url>
    <content type="text"><![CDATA[8.概念回顾 1、ConnectionFactory、Connection、Channel&emsp;ConnectionFactory、Connection、Channel都是RabbitMQ对外提供的API中最基本的对象。&emsp;Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。&emsp;ConnectionFactory为Connection的制造工厂。&emsp;Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。 2、Queue&emsp;Queue（队列）是RabbitMQ的内部对象，用于存储消息，用下图表示。 属性：&emsp;&emsp;name：名字&emsp;&emsp;Durability：是否持久化，Durable（是），Transient（否）&emsp;&emsp; Exclusive:排他性&emsp;&emsp;Auto Delete：如果选择yes，代表当最后一个监听移除后队列会自动删除&emsp;&emsp;Arguments:自定义扩展属性&emsp;RabbitMQ中的消息都只能存储在Queue中，生产者（下图中的P）生产消息并最终投递到Queue中，消费者（下图中的C）可以从Queue中获取消息并消费。&emsp;多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。 3、Binding&emsp;RabbitMQ中通过Binding将Exchange与Queue关联起来，这样RabbitMQ就知道如何正确地将消息路由到指定的Queue了。 4、Binding key&emsp;在绑定（Binding）Exchange与Queue的同时，一般会指定一个binding key；消费者将消息发送给Exchange时，一般会指定一个routing key；当binding key与routing key相匹配时，消息将会被路由到对应的Queue中。&emsp;在绑定多个Queue到同一个Exchange的时候，这些Binding允许使用相同的binding key。&emsp;binding key 并不是在所有情况下都生效，它依赖于Exchange Type，比如fanout类型的Exchange就会无视binding key，而是将消息路由到所有绑定到该Exchange的Queue。 5、Exchange&emsp;生产者将消息发送到Exchange（交换器，下图中的X），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。 &emsp; &emsp;Exchange是按照什么逻辑将消息路由到Queue的？ &emsp; &emsp;RabbitMQ中的Exchange有四种类型，不同的类型有着不同的路由策略 6、Message&emsp;服务器和应用程序之间传递的数据，就是数据，有Properties和Body组成,属性有以下:&emsp;content_type&emsp;content_encoding&emsp;priority：优先级从0-9，这个优先级不一定越高获取越先&emsp;correlation_id：一般用来消息的唯一id，做一些ack，消息的路由，幂等情况下用到&emsp;expiration：消息存活时间&emsp;message_id&emsp;timestamp&emsp;type&emsp;user_id&emsp;app_id&emsp;cluster_id &emsp;这些属性有很多，我们会在接下来的课程中给大家逐一讲解到,首先我们先来看下如何在发送消息的时候设置消息的属性，编写一个基本的生产者消费者的代码&emsp;以下代码创建连接工厂、得到连接、创建Channel等省略&emsp; 在生产者这边我们指定了消息的持久化模式，编码，生命时长，包括自定义的属性，接下来我们看下消费者 7、Virtual Host 虚拟主机&emsp;虚拟地址，用于进行逻辑隔离，最上层的消息路由,一个Virtual Host里可以有若干个Exchange和Queue&emsp;同一个Virtual Host里面不能有相同的名称的Exchange 或Queue]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ7]]></title>
    <url>%2F2019%2F09%2F06%2FRabbitMQ7%2F</url>
    <content type="text"><![CDATA[7.Exchange交换机 Exchang：用来接收消息，并且根据路由键转发消息所绑定的队列的，我们来看下官网的这张图在这张图中描述了这样的几个部分 &emsp;蓝色区域：表示消息的发送要经过的处理，在上一节我们看到生产者将消息投递到Queue中，实际上这在RabbitMQ中这种事情永远都不会发生。实际的情况是，生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。&emsp;绿色区域：消息接受者（消费者）从队列中获取消息&emsp;红色区域：表示rabbitmq server中工作的一些组件&emsp;黄色区域：指Exchange通过RoutingKey和Queue绑定在一起 交换机的属性&emsp;Name：交换机名字&emsp;Type：交换机类型 direct、topic、fanout、headers&emsp;Durability：是否需要持久化，true为持久化&emsp;Auto Delete：当最后一个绑定到Exchange上的队列删除后，自动删除该Exchange&emsp;Arguments：扩展参数，用于扩展AMQP协议自制定化使用&emsp;Internal：当前Exchange是否用于RabbitMQ内部使用，默认false，一般熟悉erlang自己扩展插件才会用到 接下来来详细讲下这几种模式1.Direct Exchange&emsp;所有发送到Direct Exchange的消息被转发到RouteKey中制定的Queue,Direct模式可以使用RabbitMQ自带的Exchange：default Exchange，所以不需要将Exchange进行任何的绑定操作，消息传递时，Routekey必须完全匹配才会被队列接收，否则该消息会被抛弃&emsp;以上图的配置为例，我们以routingKey=”error”发送消息到Exchange，则消息会路由到Queue1（amqp.gen-S9b…，这是由RabbitMQ自动生成的Queue名称）和Queue2（amqp.gen-Agl…）；如果我们以routingKey=”info”或routingKey=”warning”来发送消息，则消息只会路由到Queue2。如果我们以其他routingKey发送消息，则消息不会路由到这两个Queue中。看下生产者和消费者的代码,连接和关闭等代码不变，我们看下核心的变化生产者 1234567/***4.声明&amp;emsp;我们需要声明下交换机的名字，以及路由键*/String exchangeName="test_direct_echange";String rountingKey="test.direct";//5.发送，这个时候需要指定了在那个交换机下，通过指定的rountingKsy去访问channel.basicPublish(excahngeName,rountingKsy,null,"你好".getBytes()); 消费者通过这个案例中，我们可以看出direct这种直连模式，通过指定的routingKey去访问对应的交换机中的队列 2.Topic Exchange&emsp;前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，topic是一种模糊匹配，它约定：&emsp;routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”&emsp;binding key与routing key一样也是句点号“. ”分隔的字符串。&emsp;binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）。&emsp;以上图中的配置为例，routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2，routingKey=”lazy.orange.fox”的消息会路由到Q1与Q2，routingKey=”lazy.brown.fox”的消息会路由到Q2，routingKey=”lazy.pink.rabbit”的消息会路由到Q2（只会投递给Q2一次，虽然这个routingKey与Q2的两个bindingKey都匹配）；routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit”的消息将会被丢弃，因为它们没有匹配任何bindingKey。生产者消费者 3.fanout&emsp;fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。也就是完全忽略routingKey&emsp;上图中，生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。我们只需要在消费者中不指定routingKey，生产者也不主要关注routingKey，只需要关注交换机就好了生产者消费者 4.headers&emsp;headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。&emsp; 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。&emsp;该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ R6]]></title>
    <url>%2F2019%2F09%2F06%2FRabbitMQ6%2F</url>
    <content type="text"><![CDATA[6生产者 接下来我们用代码来实现一个简单的生产者和消费者的案例，首先创建一个springBoot工程，没有接触过springBoot的同学就创建一个maven工程也可以，然后在pom.xml中导入rabbitmq的依赖 123456&lt;!--rabbitmq依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;3.6.5&lt;/version&gt;&lt;/dependency&gt; 接着我们来编写生产者类，代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Procuder &#123; public static void main(String[] args)throws Exception &#123; //1.创建一个ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("192.168.3.5"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost("/test"); connectionFactory.setUsername("admin"); connectionFactory.setPassword("123456"); //2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3.通过connection创建一个Channel Channel channel = connection.createChannel(); String queueName = "test001"; //4.发送 channel.basicPublish("",queueName,null,"哈喽啊".getBytes()); //5.关闭连接 channel.close(); connection.close(); &#125;&#125;消费者public class Consumer &#123; public static void main(String[] args)throws Exception &#123; //1.创建一个ConnectionFactory ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost("192.168.3.5"); connectionFactory.setPort(5672); connectionFactory.setVirtualHost("/test"); connectionFactory.setUsername("admin"); connectionFactory.setPassword("123456"); //2.通过连接工厂创建连接 Connection connection = connectionFactory.newConnection(); //3.通过connection创建一个Channel Channel channel = connection.createChannel(); /** * 4.声明一个队列 * 参数1 队列的名字 * 参数2 是否持久化队列，我们的队列模式是在内存中的，如果rabbitmq重启会丢失，如果我们设置为true则会保存 * 到erlang自带的数据库中，重启后会读取 * 参数3 是否排外，有两个作用，第一个当我们的连接关闭后是否会自动删除队列，第二个，是否私有当前队列 * 如果私有了其他通道不可以访问当前队列，如果为true，一般是一个队列只适用于一个消费者的时候 * 参数4 是否自动删除 * 参数5 一些其他的参数 */ String queueName = "test001"; channel.queueDeclare(queueName,false,false,false,null); //5.创建消费者 QueueingConsumer queueingConsumer = new QueueingConsumer(channel); channel.basicConsume(queueName,true,queueingConsumer); //6.获取消息,如果没有消息会等待，有就获取，可以指定等待时间 QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery(); String msg = new String(delivery.getBody()); System.out.println("接收到"+msg); //7.关闭 channel.close(); connection.close(); &#125;]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ R5]]></title>
    <url>%2F2019%2F08%2F10%2FRabbitMQ5%2F</url>
    <content type="text"><![CDATA[5. 命令行 命令行12345678910rabbitmqctl stop_app：关闭应用rabbitmqctl start_app： 启动应用rabbitmqctl status ：节点状态rabbitmqctl add_user username password：添加用户rabbitmqctl list_users：列出所有用户rabbitmqctl delete_user username：删除用户rabbitmqctl clear_permissions -p vhostpath username：清除用户权限rabbitmqctl list_user_permissions username：列出用户权限rabbitmqctl change_password username newpassword：修改密码rabbitmqctl set_permissions -p vhostpath username ".*" ".*" ".*" ：设置用户权限 操作组件（虚拟主机，交换机，队列）12345678910111213rabbitmqctl add_vhost vhostpath：创建虚拟主机rabbitmqctl list_vhosts：列出所有虚拟主机rabbitmqctl list_permissions -p vhostpath：列出虚拟主机上所有的权限rabbitmqctl delete_vhost vhostpath：删除虚拟主机rabbitmqctl list_queues：查看所有队列信息rabbitmqctl -p vhostpath purge_queue blue：清除队列里的消息rabbitmqctl reset ：移除所有的数据，要在rabbitmqctl stop_app之后使用rabbitmqctl join_cluster &lt;clusternode&gt; [--ram] ：组成集群命令rabbitmqctl change_cluster_node_type disc | ram：修改集群节点的存储形式rabbitmqctl forget_cluster_node [--offline] ：忘记节点，摘除节点，用来失败转移rabbitmqctl rename_cluster_node oldnode1 newnode1 [oldnode2] [newnode2] ：修改节点名称]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ R4]]></title>
    <url>%2F2019%2F08%2F05%2FRabbitMQ4%2F</url>
    <content type="text"><![CDATA[4. RabbitMQ的安装 首先安装依赖1yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel httpd python-simplejson 安装Erlang1234567wget http://erlang.org/download/otp_src_19.0.tar.gztar -vxf otp_src_19.0.tar.gzcd otp_src_19.0./configure --prefix=/usr/local/erlang --with-ssl -enable-threads -enable-smmp-support -enable-kernel-poll --enable-hipe --without-javacmake &amp;&amp; make install 然后打开文件，在最下面插入这一段1234vim /etc/profileexport ERLANG_HOME=/usr/local/erlangexport PATH=$PATH:$ERLANG_HOME/bin 然后刷新下 123source /etc/profileerl -v (检查erlang是否安装完成)` 安装rabbitmq 123wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.6/rabbitmq-server-3.6.6-1.el6.noarch.rpmyum -y install rabbitmq-server-3.6.6-1.el6.noarch.rpm 这里可能会报错解决方法：yum -y install socat此时会报错没有socat包或是找不到socat包，解决方法安装centos的epel的扩展源yum -y install epel-release 之后执行yum -y install socat 再重新安装rabbitmq-server 123456789101112131415161718192021222324252627282930313233343536373839404142yum -y install rabbitmq-server-3.6.6-1.el6.noarch.rpmsystemctl start rabbitmq-server (一定要执行 不然会报错)rabbitmq状态service rabbitmq-server status启动rabbitmq service rabbitmq-server start 暂停rabbitmqservice rabbitmq-server stop service rabbitmq-server restartservice rabbitmq-server try-restartservice rabbitmq-server reloadservice rabbitmq-server force-reload 开机启动rabbitmqchkconfig rabbitmq-server on查看rabbitMq进程ps -ef | grep rabbitmq 启动web管理页面rabbitmq-plugins enable rabbitmq_management （http://127.0.0.1:15672）`默认用户名密码 guest guest (只能localhost登录)查看用户列表rabbitmqctl list_users添加用户rabbitmqctl add_user admin 123456添加角色rabbitmqctl set_user_tags admin administrator设置权限rabbitmqctl set_permissions -p / admin ".*" ".*" ".*" 注意： 5672端口是连接rabbitmq用的]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ R3]]></title>
    <url>%2F2019%2F08%2F02%2FRabbitMQ3%2F</url>
    <content type="text"><![CDATA[3. AMQP核心概念 AMQP核心概念&emsp;&emsp;AMQP全程是：Advanced Message Queuing Protocol(高级消息队列协议)AMQP定义：是具有现代特征的二进制协议。是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。 各个名词的概念Server：又称Broker，接收客户端的连接，实现AMQP的实体服务Connection：连接，应用程序与Broker的网络连接Channel：网络通道，几乎所有的操作都在Channel中进行，Channel是进行消息读写的通道，客户端可以建立多个Channel，每个Channel代表一个会话任务Message：消息，服务器和应用程序之间传送的数据，由Properties和Body组成，Properties可以对消息进行修饰，比如消息的优先级、延迟等高级特性，Body就是消息的真实内容Virtual host：虚拟地址，用于进行逻辑隔离，最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue，同一个Virtual Host里面不能有相同名称的Exchange或QueueExchange：交换机，接收消息，根据路由键转发消息到绑定的QueueBinding：Exchange和Queue之间的虚拟连接，binding中可以包含routing keyRouting key：一个路由规则，虚拟机可以用它来确定如何路由一个特定的消息Queue：Message Queue，消息队列，保存消息并将它们转发给消费者]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ R2]]></title>
    <url>%2F2019%2F08%2F01%2FRabbitMQ2%2F</url>
    <content type="text"><![CDATA[2.详细了解rabbitMQ 一、RabbitMQ &emsp; &emsp; rabbitmq是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，比如我们可以把一个用java开发的应用和一个其他语言的应用之间交互信息 二、哪些公司在用，为什么？&emsp; 滴滴、美团、头条等等都在使用。 开源、性能优秀、稳定性保障，提可靠的消息投递模式、返回模式 与SpringAMQP完美整合，API丰富 集群模式丰富，表达式配置，HA模式，镜像队列模式 保证数据不丢失做到高可靠性、可用性 三、RabbitMQ高性能的原因 &emsp; 因为是Erlang语言编写的，Erlang是一种函数式语言，使用Erlang编写出的应用运行时通常由成千上万个轻量级进程组成，并通过消息传递相互通讯。使用 Erlang来编写分布式应用比其它语言简单许多，因为它的分布式机制是透明的，即对于程序而言并不知道自己是在分布式运行。Erlang运行环境是一个 虚拟机，有点类似于Java虚拟机，代码一经编译，同样可以随处运行。它的运行时系统甚至允许代码在不被中断的情况下更新。另外如果需要更高效的话，字节 代码也可以编译成本地代码运行。 &emsp; 目的是创造一种可以应对大规模并发活动的编程语言和运行环境Erlang语言最初在于交换机领域的架构模式，这样使得RabbitMQ在Broker之间进行数据交互的性能非常优秀]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ R1]]></title>
    <url>%2F2019%2F08%2F01%2FRabbitMQ1%2F</url>
    <content type="text"><![CDATA[1. rabbitMQ相关概念 一、简介MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。其中较为成熟的MQ产品有IBM WEBSPHERE MQ等等… 二、使用场景 &emsp; &emsp;在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。 三、相关名称介绍1、ConnectionFactory、Connection、Channel &emsp; &emsp;ConnectionFactory、Connection、Channel都是RabbitMQ对外提供的API中最基本的对象。 &emsp; &emsp;Connection是RabbitMQ的socket链接，它封装了socket协议相关部分逻辑。 &emsp; &emsp;ConnectionFactory为Connection的制造工厂。 &emsp; &emsp;Channel是我们与RabbitMQ打交道的最重要的一个接口，我们大部分的业务操作是在Channel这个接口中完成的，包括定义Queue、定义Exchange、绑定Queue与Exchange、发布消息等。 2、Queue &emsp; &emsp;Queue（队列）是RabbitMQ的内部对象，用于存储消息， &emsp; &emsp;RabbitMQ中的消息都只能存储在Queue中，生产者（下图中的P）生产消息并最终投递到Queue中，消费者（下图中的C）可以从Queue中获取消息并消费. &emsp; &emsp;多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。 3、Message acknowledgment &emsp; &emsp;在实际应用中，可能会发生消费者收到Queue中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给RabbitMQ，RabbitMQ收到消息回执（Message acknowledgment）后才将该消息从Queue中移除；如果RabbitMQ没有收到回执并检测到消费者的RabbitMQ连接断开，则RabbitMQ会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在timeout概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开。 &emsp; &emsp;这里会产生另外一个问题，如果我们的开发人员在处理完业务逻辑后，忘记发送回执给RabbitMQ，这将会导致严重的bug——Queue中堆积的消息会越来越多；消费者重启后会重复消费这些消息并重复执行业务逻辑… &emsp; &emsp;另外pub message是没有ack的。 4、Message durability &emsp; &emsp;如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue与Message都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。但依然解决不了小概率丢失事件的发生（比如RabbitMQ服务器已经接收到生产者的消息，但还没来得及持久化该消息时RabbitMQ服务器就断电了），如果我们需要对这种小概率事件也要管理起来，那么我们要用到事务。由于这里仅为RabbitMQ的简单介绍，所以这里将不讲解RabbitMQ相关的事务。5、Prefetch count &emsp; &emsp;前面我们讲到如果有多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息。6、Exchange &emsp; &emsp;在上一节我们看到生产者将消息投递到Queue中，实际上这在RabbitMQ中这种事情永远都不会发生。实际的情况是，生产者将消息发送到Exchange（交换器，下图中的X），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。 &emsp; &emsp;Exchange是按照什么逻辑将消息路由到Queue的？这个将在下面的8、Binding中介绍。 &emsp; &emsp;RabbitMQ中的Exchange有四种类型，不同的类型有着不同的路由策略，这将在下面的10、Exchange Types中介绍。 7、routing key &emsp; &emsp; 生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。 &emsp; &emsp;在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。8、Binding &emsp; &emsp;RabbitMQ中通过Binding将Exchange与Queue关联起来，这样RabbitMQ就知道如何正确地将消息路由到指定的Queue了。9、Binding key &emsp; &emsp;在绑定（Binding）Exchange与Queue的同时，一般会指定一个binding key；消费者将消息发送给Exchange时，一般会指定一个routing key；当binding key与routing key相匹配时，消息将会被路由到对应的Queue中。这个将在Exchange Types章节会列举实际的例子加以说明。 &emsp; &emsp;在绑定多个Queue到同一个Exchange的时候，这些Binding允许使用相同的binding key。 &emsp; &emsp;binding key 并不是在所有情况下都生效，它依赖于Exchange Type，比如fanout类型的Exchange就会无视binding key，而是将消息路由到所有绑定到该Exchange的Queue。10、Exchange Types &emsp; &emsp; RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种（AMQP规范里还提到两种Exchange Type，分别为system与自定义，这里不予以描述），下面分别进行介绍。 &emsp; &emsp;fanout &emsp; &emsp;fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。 &emsp; &emsp;生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。 &emsp; &emsp;direct &emsp; &emsp;direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。&emsp; &emsp;我们routingKey=”error”发送消息到Exchange，则消息会路由到Queue1（amqp.gen-S9b…，这是由RabbitMQ自动生成的Queue名称）和Queue2（amqp.gen-Agl…）；如果我们以routingKey=”info”或routingKey=”warning”来发送消息，则消息只会路由到Queue2。如果我们以其他routingKey发送消息，则消息不会路由到这两个Queue中。 &emsp; &emsp;topic &emsp; &emsp;前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定： &emsp; &emsp;routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” &emsp; &emsp;binding key与routing key一样也是句点号“. ”分隔的字符串。 &emsp; &emsp;binding key中可以存在两种特殊字符“”与“#”，用于做模糊匹配，其中“”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）。 &emsp; &emsp;routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2，routingKey=”lazy.orange.fox”的消息会路由到Q1与Q2，routingKey=”lazy.brown.fox”的消息会路由到Q2，routingKey=”lazy.pink.rabbit”的消息会路由到Q2（只会投递给Q2一次，虽然这个routingKey与Q2的两个bindingKey都匹配）；routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit”的消息将会被丢弃，因为它们没有匹配任何bindingKey。 &emsp; &emsp;headers &emsp; &emsp;headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 &emsp; &emsp;在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。 &emsp; &emsp; 该类型的Exchange没有用到过（不过也应该很有用武之地），所以不做介绍。11、RPC &emsp; &emsp; MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。 &emsp; &emsp;但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。在RabbitMQ中也支持RPC。 &emsp; &emsp;RabbitMQ中实现RPC的机制是： &emsp; &emsp;客户端发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14中properties，这些属性会随着消息一起发送）中设置两个值replyTo（一个Queue名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue中）和correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败）； &emsp; &emsp;服务器端收到消息并处理； &emsp; &emsp;服务器端处理完消息后，将生成一条应答消息到replyTo指定的Queue，同时带上correlationId属性； &emsp; &emsp;客户端之前已订阅replyTo指定的Queue，从中收到服务器的应答消息后，根据其中的correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理。]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文]]></title>
    <url>%2F2019%2F07%2F16%2Fhellow%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 测试Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>视频评论</category>
      </categories>
      <tags>
        <tag>testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界]]></title>
    <url>%2F2019%2F07%2F16%2Fword%2F</url>
    <content type="text"><![CDATA[MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求。其中较为成熟的MQ产品有IBM WEBSPHERE MQ等等… 世界Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>电影评论</category>
        <category>科幻</category>
      </categories>
      <tags>
        <tag>world</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文]]></title>
    <url>%2F2019%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 测试Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>电影评论</category>
        <category>科幻</category>
      </categories>
      <tags>
        <tag>hellow-world</tag>
      </tags>
  </entry>
</search>
